---
title: 2D Graphics, Coordinaten en Game State
---

Of je nu een afbeelding gebruikt om de player te tonen, of particles om een explosie duidelijk te maken, een game heeft altijd graphics en effecten nodig. In dit hoofdstuk bekijken we een aantal bouwstenen die je nodig hebt om die afbeeldingen goed te gebruiken.

# Game Window

Het eerste waar het over moeten hebben is het game window. Er zijn twee manieren om je game te tonen. In _windowed_ mode kies je een specifieke resolutie voor je window, en zie je je game als een _window_, net zoals andere progamma's. Daarnaast is er ook de _Full-screen_ mode die je hele scherm inneemt. Hier leer je hoe je wisselt tussen deze twee modes.

1. Maak een nieuw project met de naam GameWindowSize.
2. In de Game1 class declareer je de variabelen windowWidth en windowHeight:

    ```csharp
    public class Game1 : Game {
        GraphicsDeviceManager graphics;
        SpriteBatch spriteBatch;

        int windowWidth = 1000;
        int windowHeight = 800;
    ```

3. Nu kan je deze waarden gebruiken in de constructor. Daarmee stel je de beginwaarden voor de hoogte en breedte van je game in.

    ```csharp
    graphics = new GraphicsDeviceManager(this);
    graphics.PreferredBackBufferWidth = windowWidth;
    graphics.PreferredBackBufferHeight = windowHeight;
    ```
4. Nu kan je in de update functie kijken of er een toets ingedrukt wordt en zo wisselen tussen twee modi. Denk er wel aan dat je deze wijzigingen ook moet toepassen met _ApplyChanges()_. Hierboven was dat niet nodig omdat de game nog niet gestart was.

    ```csharp
    if(Keyboard.GetState().IsKeyDown(Keys.K) && !graphics.IsFullScreen)
    {
        graphics.PreferredBackBufferWidth = 1920;
        graphics.PreferredBackBufferHeight = 1080;
        graphics.IsFullScreen = true;
        graphics.ApplyChanges();
    }

    if(Keyboard.GetState().IsKeyDown(Keys.L) && graphics.IsFullScreen)
    {
        graphics.PreferredBackBufferWidth = windowWidth;
        graphics.PreferredBackBufferHeight = windowHeight;
        graphics.IsFullScreen = false;
        graphics.ApplyChanges();
    }
    ```

## Oefeningen
1. Gebruik ook eens andere waarden voor een windowed game.
2. Wat gebeurt er wanneer je de schermverhoudingen niet wijzigt en overschakelt naar fullscreen?
3. Wat gebeurt er wanneer je _ApplyChanges_ vergeet?
4. Hoe kan je met een enkele toets (F12) wisselen tussen de twee modi?

# Textures

Je leerde in het vorige hoofdstuk al hoe je afbeeldingen kan tonen. Je leerde dat je, om gebruik te kunnen maken van object zoals `spriteBatch` en `ContentManager` in je `Player` class, je deze objecten moest doorgeven als functie argumenten. Hier gebruiken we een andere aanpak. We maken deze objecten `static` in de game. Zo kan je ze vanuit elk object gebruiken.

## Statics

1. Pas de definities in je `Game1` class aan:

    ```csharp
    public static SpriteBatch sSpriteBatch;
    public static ContentManager sContent;
    public static GraphicsDeviceManager sGraphics;
    ```

## Texture Class

2. Maak in je project een nieuwe folder `Support`. Daarin voeg je een nieuwe class toe `Texture`.
3. De `Texture` class lijkt sterk op de player class in het vorige hoofdstuk. We laten dan ook opnieuw een afbeelding zien. Voeg eerst de nodige variabelen toe voor een image, positie en grootte:
    ```csharp
    Texture2D image;
    Vector2 position;
    Vector2 size;
    ```
4. De constructor moet je toelaten de naam van de afbeelding door te geven, zijn positie en grootte. Merk op dat we geen `ContentManager` moeten doorgeven. We kunnen gewoon de contentManager van `Game1` gebruiken omdat die nu `static` is.
   ```csharp
   public Texture(String image, Vector2 position, Vector2 size)
   {
      this.image = Game1.sContent.Load<Texture2D>(image);
      this.position = position;
      this.size = size;
   }
   ```

5. In de `Update` functie geven we niet echt de positie en schaal door, maar de wijziging ten opzichte van de huidige positie en schaal. Met andere woorden: we geven door hoeveel de huidige positie naar boven, onder, links of rechts moet. Zo'n wijziging noemen we een delta. Daarover leer je later meer.
   ```csharp
   public void Update(Vector2 deltaTranslate, Vector2 deltaScale)
   {
      position += deltaTranslate;
      size += deltaScale;
   }
   ```

6. In de `Draw` functie maken we eerst een rechthoek. Deze keer gebruiken we een andere constructor. We werken niet met `Point` objecten, maar geven dadelijk integers in. Dit omdat `Vector2` float coordinaten bevat een Rectangle integers verwacht.
    ```csharp
    public void Draw()
    {
       Rectangle destRect = new Rectangle((int)position.X, (int)position.Y, (int)size.X, (int)size.Y);
       Game1.sSpriteBatch.Draw(image, destRect, Color.White);
    }
    ```

## Implementatie

De `Texture` class is nu klaar voor gebruik. We gebruiken deze class in `Game1`. Voer de volgende stappen uit.

1. Voeg aan de lijst met variabelen een `List` toe om textures te onthouden. We gaan zo dadelijk textures selecteren via de spatiebalk. Daarom moet je ook kunnen onthouden welke de geselecteerde texture is.
    ```csharp
    List<Support.Texture> Textures = new List<Support.Texture>();
    int selected = 0;
    ```

2. In de constructor moeten we enkele aanpassingen doen om de `static` variabelen te laten werken:
    ```csharp
    sGraphics = new GraphicsDeviceManager(this);
    Content.RootDirectory = "Content";
    sContent = Content;
    ```

3. In de functie `LoadContent()` moet ook de initialisatie van spriteBatch wat aangepast worden. Hier voegen we ook 4 afbeeldingen aan de lijst toe.
    ```csharp
    sSpriteBatch = new SpriteBatch(GraphicsDevice);

    Textures.Add(new Support.Texture("balloon", new Vector2(10, 10), new Vector2(30, 30)));
    Textures.Add(new Support.Texture("balloon", new Vector2(200, 200), new Vector2(100, 100)));
    Textures.Add(new Support.Texture("balloon", new Vector2(50, 10), new Vector2(30, 30)));
    Textures.Add(new Support.Texture("balloon", new Vector2(50, 200), new Vector2(100, 100)));
    ```

4. In de `Update` functie moet het meeste werk gebeuren. Hier moeten we eerst controleren of de spatiebalk ingedrukt werd. We wijzigen in dat geval het geselecteerde object. Daarna moeten we de WASD-toetsen controleren om de positie aan te passen, en de pijltjestoetsen om de schaal aan te passen. Die geven we dan door aan het geselecteerde object.
    ```csharp
    if(Keyboard.GetState().IsKeyDown(Keys.Space)) {
        selected++;
        if (selected >= Textures.Count) selected = 0;
    }

    var position = new Vector2();
    var scale = new Vector2();

    if (Keyboard.GetState().IsKeyDown(Keys.W)) position.Y++;
    if (Keyboard.GetState().IsKeyDown(Keys.S)) position.Y--;
    if (Keyboard.GetState().IsKeyDown(Keys.A)) position.X--;
    if (Keyboard.GetState().IsKeyDown(Keys.D)) position.X++;

    if (Keyboard.GetState().IsKeyDown(Keys.Up)) scale.Y++;
    if (Keyboard.GetState().IsKeyDown(Keys.Down)) scale.Y--;
    if (Keyboard.GetState().IsKeyDown(Keys.Left)) scale.X--;
    if (Keyboard.GetState().IsKeyDown(Keys.Right)) scale.X++;

    Textures[selected].Update(position, scale);
    ```

5. Tot slot passen we de `Draw` functie aan. Hier moeten we de static sSpriteBatch gebruiken en de lijst met textures op het scherm tonen.
    ```csharp
    sSpriteBatch.Begin();
    Textures.ForEach(texture => texture.Draw());
    sSpriteBatch.End();
    ```
    
## Oefeningen
1. Laat de objecten sneller bewegen.
2. Als de spatiebalk ingedrukt is, beweeg en schaal dan alle objecten tegelijk.
3. Voeg een nieuwe afbeelding toe wanneer je op de T toets drukt. Gebruik random getallen om de positie en de schaal te bepalen.
4. Wissel af met full-screen mode. Wat is het probleem?

# Coordinate System

In het vorige deel leerde je textures op het scherm zetten. Maar je kon ook zien dat er een probleem is: de positie van de textures wijzigt niet met de grootte van je window. Ook zou de y-as beter omgekeerd werken en kunnen we objecten beter schalen met de positie in het centrum. Dat komt allemaal omdat we de default _pixel space_ gebruiken.

Die _pixel space_ is de meest primitieve manier om met coordinaten om te gaan. Omdat niet elk coordinaten systeem het meest geschikt is voor eender welke game, gebruikt monogame de _pixel space_. Het is aan jou om daar op verder te bouwen. In dit voorbeeld stellen we vier eisen:
- De y-as moet omgekeerd werken.
- De coordinaten mogen niet afhankelijk zijn van het aantal pixels.
- Het midden van het scherm wordt het nulpunt.
- De hoogte van het scherm schalen we tussen -1 en 1. De breedte is dan afhankelijk van de hoogte.

Dat laatste punt zorgt er voor dat we de Textures nu met veel kleinere afmetingen moeten maken.  We zullen dus eerst het laden van de textures aanpassen:

```csharp
Textures.Add(new Support.Texture("balloon", new Vector2(0, 0), new Vector2(0.3f, 0.3f)));
Textures.Add(new Support.Texture("balloon", new Vector2(-0.5f, -0.5f), new Vector2(0.3f, 0.3f)));
Textures.Add(new Support.Texture("balloon", new Vector2(0.7f, 0.7f), new Vector2(0.1f, 0.1f)));
Textures.Add(new Support.Texture("balloon", new Vector2(-0.5f, 0.5f), new Vector2(0.4f, 0.2f)));
```

## Camera class

Dan maken we in de `Support` folder een class `Camera`. Omdat we altijd slechts 1 camera willen, wordt dit een static class. De class heeft twee variabelen nodig:
- sScale wordt de schaal. Die hebben we nodig om Coordinaten tussen -1 en 1 om te zetten naar pixel coordinaten.
- sOffset hebben we nodig omdat het nulpunt niet langer linksboven ligt. We moeten alle schermcoordinaten verplaatsen naar het eigenlijke nulpunt.

```csharp
static public class Camera
{
    static private float sScale;
    static private Point sOffset;
}
```

De eerste functie die we toevoegen zet een `Vector2` grootte om naar een `Point` pixel coordinaat. Deze functie gebruiken we niet voor posities, maar om de grootte _(size)_ van een `Rectangle` te converteren. De offset hebben we daarom niet nodig. 

```csharp
static private Point ConvertToSize(Vector2 value)
{
    Point point = new Point();
    point.X = (int)(value.X * sScale);
    point.Y = (int)(value.Y * sScale);
    return point;
}
```

Daarnaast hebben we ook een functie nodig om een echte schermpositie te berekenen. Hier heb je wel een offset nodig. Ook moeten we hier de `Y` waarde omkeren omdat we die van beneden naar boven willen.

```csharp
static private Point ConvertToPosition(Vector2 value)
{
    Point point = new Point();
    point.X = (int)(value.X * sScale);
    point.Y = (int)(-value.Y * sScale);
    return sOffset + point;
}
```

Dan volgt de publieke functie die we buiten de class zullen aanroepen `ScreenRectangle`. Die zet een positie en een schaling om naar een rechthoek in _pixel space_. Om de positie samen te laten vallen met het midden van de rechthoek in plaats van de linkerbovenhoek, trekken we de helft van de schaal af van de positie.

```csharp
static public Rectangle ScreenRectangle(Vector2 position, Vector2 size)
{
    Point p = ConvertToPosition(position);
    Point s = ConvertToSize(size);

    return new Rectangle(p - new Point(s.X / 2, s.Y / 2), s);
}
```

Tot slot schrijven we een `Setup` functie. Telkens als we de resolutie van het window wijzigen _(of overschakelen naar fullscreen)_ moeten we de offset en de schaal berekenen.

```csharp
static public void Setup()
{
    sOffset.X = Game1.sGraphics.PreferredBackBufferWidth / 2;
    sOffset.Y = Game1.sGraphics.PreferredBackBufferHeight / 2;
    sScale = sOffset.Y;
}
```

De bovenstaande functie moet je dan in de class `Game1` uitvoeren. Dit doe je op het eind de `Initialize` functie:

```csharp
protected override void Initialize()
{
    base.Initialize();
    Support.Camera.Setup();
}
```

## Texture
We begonnen met de `Textures` andere coordinaten te geven. De laatste stap bestaat er nu in om die coordinaten om te zetten naar de _pixel space_. Dat doen we pas op het laatste moment, net voordat we de rechthoek tekenen. De `Draw` functie van de  `Texture` class kan je zo aanpassen:

```csharp
public void Draw()
{
    Rectangle destRect = Camera.ScreenRectangle(position, size);
    Game1.sSpriteBatch.Draw(image, destRect, Color.White);
}
```

## Oefeningen
1. Voeg een object helemaal boven in het midden van het scherm toe.
2. Voeg een object helemaal beneden, rechts in het scherm toe. _(Blijf dit even oefenen totdat je intuitief weet wat voor waarden je nodig hebt voor verschillende posities.)_
3. Voeg code toe om je Camera een zoomfunctie te geven. Je moet daarvoor een zoom delta doorgeven aan de `Camera` class. Een beetje zoals de functies in `Texture` waarmee je de positie en de schaal kan aanpassen. Ook zal je in `Game1` twee toetsen moeten gebruiken om de zoom groter en kleiner te maken.
4. Voeg ook code toe om de camera te bewegen.
5. Zorg er voor dat je via de `N` toets telkens een extra Texture toevoegt aan je game. Elke texture moet een Random positie en schaal hebben.

# Tekst
Bijna elke game toont wel ergens tekst op het scherm. Tekst kan je gebruiken om bijvoorbeeld de score of een naam te tonen. Maar ook tijdens de ontwikkeling van een spel is tekst een eenvoudige manier om de waarde van een variabele in de gaten te houden. In een console programma is het tonen van tekst heel eenvoudig. Helaas is het in MonoGame _(en zowat elke andere game engine)_ minder gemakkelijk. Ten eerste kan je niet zomaar fonts gebruiken. We moeten eigenlijk van elke letter die je op het scherm wil tonen een afbeelding maken. Gelukkig is er de `SpriteFont` class om je te helpen.

## Een font toevoegen
Voordat je tekst kan tonen moet je eerst een font maken. Dat doe je door de __Pipeline Tool__ te openen. Je voegt een nieuwe item toe en je kiest voor `SpriteFont Description`. Vergeet ook niet bovenaan je font een naam te geven. Daarna kan je de font definitie openen in een tekst editor. De inhoud lijkt wat op een HTML bestand. Je kan daarin de naam van je font wijzigen en de eigenschappen aanpassen. Let wel op: de naam van het font moet bestaan op je computer. Tot slot kies je de `Build` actie om je font te genereren. De __Pipeline Tool__ zal je font genereren en daarna kan je dat venster sluiten. Als er fouten in je bestand staan, dan zal je die op het scherm zien.

## Font Support
In de `Support` folder maak je nu ook een static class `Font`. Er zijn twee variabelen nodig: een font en de scherm positie. 

```csharp
static class Font
{
    static private SpriteFont sFont;
    static private Vector2 sLocation = new Vector2(5, 5);
}
```

Net zoals de `Camera` class heeft ook font een setup functie nodig. Die laadt het font in het geheugen. De manier waarop dat gebeurt is gelijkaardig aan de manier waarop je een afbeelding laadt:

```csharp
static public void Setup()
{
    sFont = Game1.sContent.Load<SpriteFont>("Arial");
}
```

Een volgende functie laat ons toe om eenvoudig de status van een object op het scherm te tonen. We gebruiken daarvoor de `DrawString` functie van `SpriteBatch`. Die heeft een font nodig, samen met een tekst, een locatie, en een kleur. Font en locatie zijn al aanwezig in deze class, maar de tekst en de kleur vragen we als functieargumenten.

```csharp
static public void PrintStatus(string msg, Color color)
{
    Game1.sSpriteBatch.DrawString(sFont, msg, sLocation, color);
}
```

De laatste functie laat toe om een tekst eender waar op het scherm te tonen. We gebruiken nu camera coordinaten. Daarom moeten we eerst de functie `Camera.ConvertToPosition` public maken, want die was voordien private. Ook zitten we met een extra probleem: het resultaat van die functie is een `Point`, met integer coordinaten. Maar de `DrawString` functie verwacht een `Vector2`, met float coordinaten. Dat valt eenvoudig op te lossen:

```csharp
static public void PrintAt(Vector2 pos, string msg, Color color)
{
    Point p = Camera.ConvertToPosition(pos);
    Game1.sSpriteBatch.DrawString(sFont, msg, new Vector2(p.X, p.Y), color);
}
```

## Drawing Text
Nu de font class klaar is, kunnen we tekst op het scherm tonen. Vergeet niet eerst de setup functie toe te voegen aan `Game1.Initialize`:

```csharp
protected override void Initialize()
{
    base.Initialize();
    Support.Camera.Setup();
    Support.Font.Setup();
}
```

In de ``Draw` functie tonen we tenslotte tekst op het scherm. In het vorige hoofdstuk plaatsten we Textures op het scherm, en via de spatiebalk kunnen we een texture selecteren. We gaan nu de positie van de geselecteerde texture op het scherm tonen. Ook gaan we de tekst _Selected_ tonen op de plaats van de geselecteerde texture. Om dat te kunnen doen moet je wel eerst een public getter voor `position` maken in de texture class. Want die variabele is private. Je leerde in de vorige cursus hoe dat moet.

```csharp
protected override void Draw(GameTime gameTime)
{
    GraphicsDevice.Clear(Color.CornflowerBlue);

    sSpriteBatch.Begin();
    Textures.ForEach(texture => texture.Draw());

    Support.Font.PrintStatus("Selected object is: " + selected + " Location=" + Textures[selected].Position, Color.Black);
    Support.Font.PrintAt(Textures[selected].Position, "Selected", Color.Red);
    sSpriteBatch.End();

    base.Draw(gameTime);
}
```


## Oefeningen
1. Waarom gebruiken we in de functie PrintStatus de _pixel space_ in plaats van ons eigen coordinaten systeem?
2. Vervang je font door Times New Roman. Pas ook de grootte van je font aan.
3. Maak een  `PrintStatus2` functie, waarmee je tekst kan tonen onder de vorige tekst. Hier toon je het aantal textures dat actief is in je game. (Een toets om Textures toe te voegen moest je in een vorige oefening al gemaakt hebben. Eventueel kan je ook een andere variabele kiezen.)
4. Nu je een functie hebt om een tweede status line toe te voegen, kan je ook eenvoudig een meer algemene functie maken met een extra argument waarmee je aangeeft op welke hoogte je je tekst wil tonen. Je kan dat positie argument dan vermenigvuldigen met de hoogte van een lijn.

# Game Objects
Tot hier toe gebruikte je de `Texture` class om afbeeldingen op het scherm te tonen. Maar niet elk object in je game zal zich op dezelfde manier gedragen. Daarom is het een goed idee om deze class als basis te gebruiken voor meer geavanceerde classes, die zelf bepalen hoe een object zich moet gedragen, maar de `Texture` class gebruiken voor de 'basics' die elk object nodig heeft, zoals de `Draw()` functie.

## Boundaries
Bijna altijd zal je in een game _boundaries_ willen gebruiken. Daarmee bedoelen we de grenzen van een object, of de grenzen van een scherm. Met boundaries kunnen we controleren of twee objecten mekaar raken, of een object de rand van het scherm raakt, of we met de muis in het object klikken enzovoort.

Eerst voegen we boundaries toe aan de `Texture` class. Dat kan met twee eenvoudige properties:

```csharp
public Vector2 MinBound { get => Position - (size * 0.5f); }
public Vector2 MaxBound { get => Position + (size * 0.5f); }
```

De boundaries van het scherm voegen we toe aan de `Camera` class. Afhankelijk van je game zou je hier ook rekening kunnen houden met de camera positie en zoom, maar dat doen we nu niet.

```csharp
static public Vector2 Min { get => new Vector2(-sOffset.X / sScale, -sOffset.Y / sScale); }
static public Vector2 Max { get => new Vector2(sOffset.X / sScale, sOffset.Y / sScale); }
```

Nu we boundaries hebben, willen we kunnen weten of een texture de rand van het scherm raakt. Daarvoor maken we eerst een `enum`. Je kan deze enum in een afzonderlijk bestand plaatsen, waarin je later ook andere enumeraties toevoegt.

```csharp
public enum CollisionStatus
{
    Top,
    Bottom,
    Left,
    Right,
    Inside,
}
```

Terug in de `Camera` class ga je tenslotte een functie toevoegen die controleert of een texture de rand van het scherm raakt:

```csharp
static public CollisionStatus GetCollision(Texture texture)
{
    if (texture.MaxBound.Y > Max.Y) return CollisionStatus.Top;
    if (texture.MinBound.X < Min.X) return CollisionStatus.Left;
    if (texture.MaxBound.X > Max.X) return CollisionStatus.Right;
    if (texture.MinBound.Y < Min.Y) return CollisionStatus.Bottom;

    return CollisionStatus.Inside;
}
```

## Game Object
We kunnen best een game object maken voor elke afbeelding die zich op een bepaalde manier gedraagt. Zo zou je game objects kunnen maken voor muren, bomen, de player, enemies...

In deze oefening gaan we voor koeien die over het scherm bewegen. De class die we maken heet dan ook `Cow`. Als je zelf een ander idee hebt, kan je de naam van de class natuurlijk aanpassen. Omdat elk game object op het scherm getoond wordt, zal je `Texture` als basis class gebruiken:

```csharp
public class Cow : Support.Texture 
{
    Vector2 direction;
}
```
Deze class heeft een variabele om de richting te onthouden waarin het object beweegt. In de constructor stellen we die richting in. We geven ook de juiste waarden door aan de basis class.

```csharp
public Cow(Vector2 position, float size) : base("Cow", position, new Vector2(size))
{
    direction.X = (float)(Game1.sRandom.NextDouble()) * 0.05f - 0.025f;
    direction.Y = (float)(Game1.sRandom.NextDouble()) * 0.05f - 0.025f;
}
```
Zoals je ziet geven we elk object een random richting. De code veronderstelt dat de class `Game1` een `Random` object bevat, zoals gevraagd in een van de vorige oefeningen. Als dat niet het geval is, of indien dat object niet static en public is, dan kan je dat nu nog aanpassen.

Verder heeft de class maar 1 functie nodig: `Update()`. Daarin bereken we de nieuwe positie van het object. Dat gebeurt door de richting bij de positie te tellen. Maar eerst gaan we wel controleren of we de rand van het scherm raken. In dat geval keren we de richting om.

```csharp
public void Update()
{
    var status = Support.Camera.GetCollision(this);
    switch (status)
    {
        case Support.CollisionStatus.Bottom:
        case Support.CollisionStatus.Top:
            direction.Y *= -1;
            break;
        case Support.CollisionStatus.Left:
        case Support.CollisionStatus.Right:
            direction.X *= -1;
            break;
    }
    Position += direction;
}
```

## Cows. Plural
De `Cow` class is klaar, maar wordt nog niet gebruikt in het programma. Daarom zullen we een `List<Cow>` object toevoegen. We starten met 1 koe op het scherm, maar via de spatiebalk kunnen we er meer toevoegen. En dat gebeurt allemaal in de class `Game1`.

Eerst zorg je voor een container om al die koeien in op te slaan. Die maken we rechtstreeks in de class, net zoals de variabelen die er al staan:

```csharp
List<Cow> Cows = new List<Cow>();
```

In de functie `LoadContent()` kan je alvast een koe toevoegen bij de start van het programma:

```csharp
Cows.Add(new Cow(new Vector2(0, 0), 0.3f));
```

In de `Update()` functie dienen er twee zaken te gebeuren: 
1. Wanneer je op de spatiebalk drukt, dan moet er een nieuwe koe toegevoegd worden.
2. Elke koe moet een update krijgen, via zijn eigen update functie.

```csharp
if(Keyboard.GetState().IsKeyDown(Keys.Space))
{
    Cows.Add(new Cow(new Vector2(0, 0), 0.3f));
}
Cows.ForEach((cow) => cow.Update());
```

Tot slot teken je alle koeien op het scherm in de `Draw()` functie, net na `sSpriteBatch.Begin()`. De class `Cow` heeft zelf geen `Draw()` functie, maar gebruikt de functie die in de Texture class aanwezig is.

```csharp
Cows.ForEach(cow => cow.Draw());
```

##
- Toon de positie van de eerste koe op het scherm.
- Toon hoeveel koeien er op het scherm staan.
- Zorg er voor dat er nooit meer dan 1 koe bijkomt wanneer je op de spatiebalk drukt.
- Zorg er voor dat elke nieuwe koe start op een random positie.
- Maak nog een tweede game object: `Rat`. Rats starten ergens op het scherm en bewegen naar rechts. Wanneer ze helemaal rechts staan, dan verplaats je ze terug naar links. 
- Elke rat heeft een willekeurige grootte.
- Hoe bepaal je of koeien dan wel ratten op de voorgrond staan?
- _(Uitdaging)_ Hoe zorg je er voor dat alle koeien even snel bewegen?