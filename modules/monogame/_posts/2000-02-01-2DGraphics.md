---
title: 2D Graphics, Coordinaten en Game State
---

Of je nu een afbeelding gebruikt om de player te tonen, of particles om een explosie duidelijk te maken, een game heeft altijd graphics en effecten nodig. In dit hoofdstuk bekijken we een aantal bouwstenen die je nodig hebt om die afbeeldingen goed te gebruiken.

# Game Window

Het eerste waar het over moeten hebben is het game window. Er zijn twee manieren om je game te tonen. In _windowed_ mode kies je een specifieke resolutie voor je window, en zie je je game als een _window_, net zoals andere progamma's. Daarnaast is er ook de _Full-screen_ mode die je hele scherm inneemt. Hier leer je hoe je wisselt tussen deze twee modes.

1. Maak een nieuw project met de naam GameWindowSize.
2. In de Game1 class declareer je de variabelen windowWidth en windowHeight:

    ```csharp
    public class Game1 : Game {
        GraphicsDeviceManager graphics;
        SpriteBatch spriteBatch;

        int windowWidth = 1000;
        int windowHeight = 800;
    ```

3. Nu kan je deze waarden gebruiken in de constructor. Daarmee stel je de beginwaarden voor de hoogte en breedte van je game in.

    ```csharp
    graphics = new GraphicsDeviceManager(this);
    graphics.PreferredBackBufferWidth = windowWidth;
    graphics.PreferredBackBufferHeight = windowHeight;
    ```
4. Nu kan je in de update functie kijken of er een toets ingedrukt wordt en zo wisselen tussen twee modi. Denk er wel aan dat je deze wijzigingen ook moet toepassen met _ApplyChanges()_. Hierboven was dat niet nodig omdat de game nog niet gestart was.

    ```csharp
    if(Keyboard.GetState().IsKeyDown(Keys.K) && !graphics.IsFullScreen)
    {
        graphics.PreferredBackBufferWidth = 1920;
        graphics.PreferredBackBufferHeight = 1080;
        graphics.IsFullScreen = true;
        graphics.ApplyChanges();
    }

    if(Keyboard.GetState().IsKeyDown(Keys.L) && graphics.IsFullScreen)
    {
        graphics.PreferredBackBufferWidth = windowWidth;
        graphics.PreferredBackBufferHeight = windowHeight;
        graphics.IsFullScreen = false;
        graphics.ApplyChanges();
    }
    ```

## Oefeningen
1. Gebruik ook eens andere waarden voor een windowed game.
2. Wat gebeurt er wanneer je de schermverhoudingen niet wijzigt en overschakelt naar fullscreen?
3. Wat gebeurt er wanneer je _ApplyChanges_ vergeet?
4. Hoe kan je met een enkele toets (F12) wisselen tussen de twee modi?

# Textures

Je leerde in het vorige hoofdstuk al hoe je afbeeldingen kan tonen. Je leerde dat je, om gebruik te kunnen maken van object zoals `spriteBatch` en `ContentManager` in je `Player` class, je deze objecten moest doorgeven als functie argumenten. Hier gebruiken we een andere aanpak. We maken deze objecten `static` in de game. Zo kan je ze vanuit elk object gebruiken.

## Statics

1. Pas de definities in je `Game1` class aan:

    ```csharp
    public static SpriteBatch sSpriteBatch;
    public static ContentManager sContent;
    public static GraphicsDeviceManager sGraphics;
    ```

## Texture Class

2. Maak in je project een nieuwe folder `Support`. Daarin voeg je een nieuwe class toe `Texture`.
3. De `Texture` class lijkt sterk op de player class in het vorige hoofdstuk. We laten dan ook opnieuw een afbeelding zien. Voeg eerst de nodige variabelen toe voor een image, positie en grootte:
    ```csharp
    Texture2D image;
    Vector2 position;
    Vector2 size;
    ```
4. De constructor moet je toelaten de naam van de afbeelding door te geven, zijn positie en grootte. Merk op dat we geen `ContentManager` moeten doorgeven. We kunnen gewoon de contentManager van `Game1` gebruiken omdat die nu `static` is.
   ```csharp
   public Texture(String image, Vector2 position, Vector2 size)
   {
      this.image = Game1.sContent.Load<Texture2D>(image);
      this.position = position;
      this.size = size;
   }
   ```

5. In de `Update` functie geven we niet echt de positie en schaal door, maar de wijziging ten opzichte van de huidige positie en schaal. Met andere woorden: we geven door hoeveel de huidige positie naar boven, onder, links of rechts moet. Zo'n wijziging noemen we een delta. Daarover leer je later meer.
   ```csharp
   public void Update(Vector2 deltaTranslate, Vector2 deltaScale)
   {
      position += deltaTranslate;
      size += deltaScale;
   }
   ```

6. In de `Draw` functie maken we eerst een rechthoek. Deze keer gebruiken we een andere constructor. We werken niet met `Point` objecten, maar geven dadelijk integers in. Dit omdat `Vector2` float coordinaten bevat een Rectangle integers verwacht.
    ```csharp
    public void Draw()
    {
       Rectangle destRect = new Rectangle((int)position.X, (int)position.Y, (int)size.X, (int)size.Y);
       Game1.sSpriteBatch.Draw(image, destRect, Color.White);
    }
    ```

## Implementatie

De `Texture` class is nu klaar voor gebruik. We gebruiken deze class in `Game1`. Voer de volgende stappen uit.

1. Voeg aan de lijst met variabelen een `List` toe om textures te onthouden. We gaan zo dadelijk textures selecteren via de spatiebalk. Daarom moet je ook kunnen onthouden welke de geselecteerde texture is.
    ```csharp
    List<Support.Texture> Textures = new List<Support.Texture>();
    int selected = 0;
    ```

2. In de constructor moeten we enkele aanpassingen doen om de `static` variabelen te laten werken:
    ```csharp
    sGraphics = new GraphicsDeviceManager(this);
    Content.RootDirectory = "Content";
    sContent = Content;
    ```

3. In de functie `LoadContent()` moet ook de initialisatie van spriteBatch wat aangepast worden. Hier voegen we ook 4 afbeeldingen aan de lijst toe.
    ```csharp
    sSpriteBatch = new SpriteBatch(GraphicsDevice);

    Textures.Add(new Support.Texture("balloon", new Vector2(10, 10), new Vector2(30, 30)));
    Textures.Add(new Support.Texture("balloon", new Vector2(200, 200), new Vector2(100, 100)));
    Textures.Add(new Support.Texture("balloon", new Vector2(50, 10), new Vector2(30, 30)));
    Textures.Add(new Support.Texture("balloon", new Vector2(50, 200), new Vector2(100, 100)));
    ```

4. In de `Update` functie moet het meeste werk gebeuren. Hier moeten we eerst controleren of de spatiebalk ingedrukt werd. We wijzigen in dat geval het geselecteerde object. Daarna moeten we de WASD-toetsen controleren om de positie aan te passen, en de pijltjestoetsen om de schaal aan te passen. Die geven we dan door aan het geselecteerde object.
    ```csharp
    if(Keyboard.GetState().IsKeyDown(Keys.Space)) {
        selected++;
        if (selected >= Textures.Count) selected = 0;
    }

    var position = new Vector2();
    var scale = new Vector2();

    if (Keyboard.GetState().IsKeyDown(Keys.W)) position.Y++;
    if (Keyboard.GetState().IsKeyDown(Keys.S)) position.Y--;
    if (Keyboard.GetState().IsKeyDown(Keys.A)) position.X--;
    if (Keyboard.GetState().IsKeyDown(Keys.D)) position.X++;

    if (Keyboard.GetState().IsKeyDown(Keys.Up)) scale.Y++;
    if (Keyboard.GetState().IsKeyDown(Keys.Down)) scale.Y--;
    if (Keyboard.GetState().IsKeyDown(Keys.Left)) scale.X--;
    if (Keyboard.GetState().IsKeyDown(Keys.Right)) scale.X++;

    Textures[selected].Update(position, scale);
    ```

5. Tot slot passen we de `Draw` functie aan. Hier moeten we de static sSpriteBatch gebruiken en de lijst met textures op het scherm tonen.
    ```csharp
    sSpriteBatch.Begin();
    Textures.ForEach(texture => texture.Draw());
    sSpriteBatch.End();
    ```
    
## Oefeningen
1. Laat de objecten sneller bewegen.
2. Als de spatiebalk ingedrukt is, beweeg en schaal dan alle objecten tegelijk.
3. Voeg een nieuwe afbeelding toe wanneer je op de T toets drukt. Gebruik random getallen om de positie en de schaal te bepalen.
4. Wissel af met full-screen mode. Wat is het probleem?

# Coordinate System

In het vorige deel leerde je textures op het scherm zetten. Maar je kon ook zien dat er een probleem is: de positie van de textures wijzigt niet met de grootte van je window. Ook zou de y-as beter omgekeerd werken en kunnen we objecten beter schalen met de positie in het centrum. Dat komt allemaal omdat we de default _pixel space_ gebruiken.

Die _pixel space_ is de meest primitieve manier om met coordinaten om te gaan. Omdat niet elk coordinaten systeem het meest geschikt is voor eender welke game, gebruikt monogame de _pixel space_. Het is aan jou om daar op verder te bouwen. In dit voorbeeld stellen we vier eisen:
- De y-as moet omgekeerd werken.
- De coordinaten mogen niet afhankelijk zijn van het aantal pixels.
- Het midden van het scherm wordt het nulpunt.
- De hoogte van het scherm schalen we tussen -1 en 1. De breedte is dan afhankelijk van de hoogte.

Dat laatste punt zorgt er voor dat we de Textures nu met veel kleinere afmetingen moeten maken.  We zullen dus eerst het laden van de textures aanpassen:

```csharp
Textures.Add(new Support.Texture("balloon", new Vector2(0, 0), new Vector2(0.3f, 0.3f)));
Textures.Add(new Support.Texture("balloon", new Vector2(-0.5f, -0.5f), new Vector2(0.3f, 0.3f)));
Textures.Add(new Support.Texture("balloon", new Vector2(0.7f, 0.7f), new Vector2(0.1f, 0.1f)));
Textures.Add(new Support.Texture("balloon", new Vector2(-0.5f, 0.5f), new Vector2(0.4f, 0.2f)));
```

## Camera class

Dan maken we in de `Support` folder een class `Camera`. Omdat we altijd slechts 1 camera willen, wordt dit een static class. De class heeft twee variabelen nodig:
- sScale wordt de schaal. Die hebben we nodig om Coordinaten tussen -1 en 1 om te zetten naar pixel coordinaten.
- sOffset hebben we nodig omdat het nulpunt niet langer linksboven ligt. We moeten alle schermcoordinaten verplaatsen naar het eigenlijke nulpunt.

```csharp
static public class Camera
{
    static private float sScale;
    static private Point sOffset;
}
```

De eerste functie die we toevoegen zet een `Vector2` grootte om naar een `Point` pixel coordinaat. Deze functie gebruiken we niet voor posities, maar om de grootte _(size)_ van een `Rectangle` te converteren. De offset hebben we daarom niet nodig. 

```csharp
static private Point ConvertToSize(Vector2 value)
{
    Point point = new Point();
    point.X = (int)(value.X * sScale);
    point.Y = (int)(value.Y * sScale);
    return point;
}
```

Daarnaast hebben we ook een functie nodig om een echte schermpositie te berekenen. Hier heb je wel een offset nodig. Ook moeten we hier de `Y` waarde omkeren omdat we die van beneden naar boven willen.

```csharp
static private Point ConvertToPosition(Vector2 value)
{
    Point point = new Point();
    point.X = (int)(value.X * sScale);
    point.Y = (int)(-value.Y * sScale);
    return sOffset + point;
}
```

Dan volgt de publieke functie die we buiten de class zullen aanroepen `ScreenRectangle`. Die zet een positie en een schaling om naar een rechthoek in _pixel space_. Om de positie samen te laten vallen met het midden van de rechthoek in plaats van de linkerbovenhoek, trekken we de helft van de schaal af van de positie.

```csharp
static public Rectangle ScreenRectangle(Vector2 position, Vector2 size)
{
    Point p = ConvertToPosition(position);
    Point s = ConvertToSize(size);

    return new Rectangle(p - new Point(s.X / 2, s.Y / 2), s);
}
```

Tot slot schrijven we een `Setup` functie. Telkens als we de resolutie van het window wijzigen _(of overschakelen naar fullscreen)_ moeten we de offset en de schaal berekenen.

```csharp
static public void Setup()
{
    sOffset.X = Game1.sGraphics.PreferredBackBufferWidth / 2;
    sOffset.Y = Game1.sGraphics.PreferredBackBufferHeight / 2;
    sScale = sOffset.Y;
}
```

## Texture
We begonnen met de `Textures` andere coordinaten te geven. De laatste stap bestaat er nu in om die coordinaten om te zetten naar de _pixel space_. Dat doen we pas op het laatste moment, net voordat we de rechthoek tekenen. De `Draw` functie van de  `Texture` class kan je zo aanpassen:

```csharp
public void Draw()
{
    Rectangle destRect = Camera.ScreenRectangle(position, size);
    Game1.sSpriteBatch.Draw(image, destRect, Color.White);
}
```

## Oefeningen
1. Voeg een object helemaal boven in het midden van het scherm toe.
2. Voeg een object helemaal beneden, rechts in het scherm toe. _(Blijf dit even oefenen totdat je intuitief weet wat voor waarden je nodig hebt voor verschillende posities.)_
3. Voeg code toe om je Camera een zoomfunctie te geven. Je moet daarvoor een zoom delta doorgeven aan de `Camera` class. Een beetje zoals de functies in `Texture` waarmee je de positie en de schaal kan aanpassen. Ook zal je in `Game1` twee toetsen moeten gebruiken om de zoom groter en kleiner te maken.
4. Voeg ook code toe om de camera te bewegen.
5. Zorg er voor dat je via de `N` toets telkens een extra Texture toevoegt aan je game. Elke texture moet een Random positie en schaal hebben.